"""Drought classifier .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r5lMR8TpATGaQWM7S0tdk6Pyz2wavwXb
"""

import pandas as pd

monthly_cols = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']

REQ_COLS = ['SUBDIVISION', 'YEAR'] + monthly_cols + ['ANNUAL']
def load_clean_df(csv_path: str = "Rainfall_Data_LL.csv") -> pd.DataFrame:
    try:
        df = pd.read_csv(csv_path)
    except FileNotFoundError:
        raise FileNotFoundError(f"CSV not found: {csv_path}")
    clean_df = df[REQ_COLS].copy()
    clean_df = clean_df.dropna(subset=monthly_cols)
    return clean_df


class DataPrep:
    # Assuming df passed here is already the 'clean_df'
    def __init__(self, df):
        self.df = df.copy()

    def get_region_df(self, region_nm):
      # filter by region and drop NaN
      region_df = self.df[self.df['SUBDIVISION'] == region_nm].copy()
      region_df =region_df.dropna(subset=monthly_cols)
      return region_df

    def compute_weights(self, region_df):
      # Monthly weights based on mean / sum of means
      monthly_means = region_df[monthly_cols].mean()
      sum_of_means = monthly_means.sum()
      # Calculate weights: mean(month) / sum of means
      weights = monthly_means / sum_of_means
      return weights

class FeatureEng:
    monthly_cols = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
    def __init__(self, region_df, weights):
        self.region_df = region_df.copy()
        self.weights = weights

    def compute_weighted_annual(self, df):
         df_copy = df.copy()
      #fill missing months with historical mean if NaN
         for month in self.monthly_cols:
            if month in df_copy.columns:
                df_copy[month] = df_copy[month].fillna(self.region_df[month].mean())
            else:
                # if month column missing in user input, fill with mean
                df_copy[month] = self.region_df[month].mean()

         # multiply each month by corresponding weight
         weighted_df = df_copy[self.monthly_cols] * self.weights

          # sum across months to get weighted annual rainfall
         weighted_annual = weighted_df.sum(axis=1)
         return weighted_annual

    def prepare_features(self, df):
        df_copy=df.copy()
        # Compute weighted annual column
        df_copy['weighted_annual'] = self.compute_weighted_annual(df_copy)

        # Optional: add any normalized features (e.g., monthly / annual ratio)
        for month in self.monthly_cols:
            df_copy[f'{month}_ratio'] = df_copy[month] / df_copy['weighted_annual']

        return df_copy

class DroughtThresholds:
    def __init__(self, region_weighted_df):
        self.df = region_weighted_df.copy()
        self.annual = self.df['weighted_annual']

    def compute_thresholds(self):
        return {
            "extreme": self.annual.quantile(0.20), # top 10 % driest years which means for this extreme drought
            "moderate": self.annual.quantile(0.40),#top 25% driest years
            "mild": self.annual.quantile(0.60)
        }

    def label_historical(self):
        t = self.compute_thresholds()
        def classify(x):
            if x < t['extreme']: return "Extreme"
            elif x < t['moderate']: return "Moderate"
            elif x < t['mild']: return "Mild"
            else: return "Normal"
        self.df['drought_class'] = self.annual.apply(classify)
        return self.df

class UserDroughtPred:
    def __init__(self, thresholds, historical_df):
        self.t = thresholds
        self.historical = historical_df

    def classify(self, val):
        if val < self.t['extreme']: return "Extreme Drought"
        elif val < self.t['moderate']: return "Moderate Drought"
        elif val < self.t['mild']: return "Mild Drought"
        else: return "No Drought"

    def probability(self, val):
        annual = self.historical['weighted_annual']
        prob = (annual < val).mean()
        return round(100-(prob * 100), 2)